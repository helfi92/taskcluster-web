const fs = require('fs');
const md = require('md-directory');
const { join } = require('path');

const rawDocsDirectoryName = 'raw';
const rawDocsPath = join(__dirname, '..', '..', rawDocsDirectoryName);
const pathMappings = {};
const projectMetadata = {};
const getProjectMetadata = projectName => {
  if (!projectMetadata[projectName]) {
    projectMetadata[projectName] = JSON.parse(
      fs.readFileSync(join(rawDocsPath, projectName, 'metadata.json'))
    );
  }

  return projectMetadata[projectName];
};

// Sort files by the order property
const sort = (a, b) => {
  const first = a.data.order;
  const second = b.data.order;

  if (typeof first !== 'number') {
    return 1;
  }

  if (typeof second !== 'number') {
    return -1;
  }

  return first - second;
};

const referenceDocs = fs.readdirSync(rawDocsPath).reduce((acc, projectName) => {
  const files = md.parseDirSync(
    join(__dirname, '..', rawDocsDirectoryName, projectName),
    { dirnames: true }
  );
  const metadata = getProjectMetadata(projectName);

  // Rename key
  Object.keys(files).forEach(oldKey => {
    const path = `reference/${metadata.tier}/${projectName}/${oldKey}`;

    delete Object.assign(files, { [path]: Object.assign(files[oldKey]) })[
      oldKey
    ];
    Object.assign(pathMappings, { [path]: join(projectName, oldKey) });
  });

  return Object.assign(acc, files);
}, {});
const files = Object.assign(
  md.parseDirSync('./src/docs', { dirnames: true }),
  referenceDocs
);

function sortByOrder(children) {
  if (children && children.length) {
    children.map(child => sortByOrder(child.children));
  }

  children.sort(sort);
}

// Traverse the nodes in order, setting `up`, `next`, and
// `prev` links.
let prevNode = null;

/* eslint-disable no-param-reassign */
function addNav(node, parentNode) {
  if (parentNode && parentNode.path) {
    node.up = {
      path: parentNode.path,
      title: (parentNode.data && parentNode.data.title) || parentNode.name,
    };
  }

  if (prevNode && prevNode.path) {
    node.prev = {
      path: prevNode.path,
      title: (prevNode.data && prevNode.data.title) || prevNode.name,
    };

    prevNode.next = {
      path: node.path,
      title: (node.data && node.data.title) || node.name,
    };
  }

  prevNode = node;
  parentNode = node;

  node.children.forEach(child => addNav(child, parentNode));
}
/* eslint-enable no-param-reassign */

const makeToc = rootPath => {
  const nodes = { children: [] };

  Object.keys(files)
    .filter(path => path.startsWith(rootPath))
    .map(path => ({ path, data: files[path].data }))
    .forEach(item => {
      let ptr = nodes;
      const path = [];

      item.path
        .replace(rootPath, '')
        .split('/')
        .forEach((name, idx) => {
          path.push(name);

          // for reference docs, ignore 'references' and 'docs'
          // at the 3th position in the filename; these are just
          // left out of the hierarchy as in
          // `mv reference/taskcluster-foo/docs/* reference/taskcluster/foo`
          if (
            rootPath === 'reference/' &&
            idx === 2 &&
            (name === 'references' || name === 'docs')
          ) {
            return;
          }

          let child = ptr.children.find(child => child.name === name);

          if (!child) {
            child = {
              name,
              children: [],
              data: Object.assign(item.data, {
                order: name === 'index' ? 0 : item.data.order || 1000,
              }),
              path: `${rootPath}${path.join('/')}`,
            };

            if (name === 'index') {
              ptr.data = child.data;
            } else {
              if (rootPath === 'reference/' && name === 'README') {
                ptr.data = child.data;
                ptr.path = `${rootPath}${path.join('/')}`;
              }

              ptr.children.push(child);
            }
          }

          ptr = child;
        });
    });

  sortByOrder(nodes.children);

  addNav(nodes, null);

  return nodes;
};

const manual = makeToc('manual/');
const reference = makeToc('reference/');
const tutorial = makeToc('tutorial/');
const rest = ['index', 'resources'].map(fileName =>
  Object.assign(files[fileName], {
    name: fileName,
    path: fileName,
    children: [],
    content: undefined,
    data: Object.assign(files[fileName].data, {
      order: files[fileName].data.order || 0,
    }),
  })
);
const toc = {
  gettingStarted: rest[0],
  manual,
  reference,
  tutorial,
  resources: rest[1],
};

fs.writeFile(
  './src/autogenerated/docsTableOfContents.json',
  `${JSON.stringify(toc)}\n`,
  err => {
    if (err) {
      // eslint-disable-next-line no-console
      console.error('Error writing docsTableOfContents file', err);
    } else {
      // eslint-disable-next-line no-console
      console.log('Documentation table of contents successfully extracted!');
    }
  }
);

// TODO: Comment about why this is needed
fs.writeFile(
  './src/autogenerated/docsPathMappings.json',
  `${JSON.stringify(pathMappings)}\n`,
  err => {
    if (err) {
      // eslint-disable-next-line no-console
      console.error('Error writing docsPathMappings file', err);
    } else {
      // eslint-disable-next-line no-console
      console.log('Documentation path mappings successfully extracted!');
    }
  }
);
